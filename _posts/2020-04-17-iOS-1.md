---
layout: post
title:  "iOS Study (Chapter 8 - 테이블 뷰와 데이터 소스 연동)"
date:   2020-04-17
categories: iOS, Swift
---

이 포스트는 꼼꼼한 재은씨의 스위프트 기본편을 보고 스스로 공부한 내용을 정리한 포스트 입니다.

- - -

### 예제 코드

- [MyMovieChart - 200417](https://github.com/VincentGeranium/Swift-Study/tree/master/MyMovieChartWithCode)

- - -

### 참고 자료

- [Apple Developer Documentation](https://developer.apple.com/documentation/)

- [데이터 소스, 데이터 소스 만들기, Value Object 패턴, 데이터 넣어주기](https://vincentgeranium.github.io/ios,/swift/2020/04/12/iOS-1.html)

- - -

### 테이블 뷰와 데이터 소스 연동

- 데이터 소스와 테이블 뷰를 연동하는 과정은 UITableViewDataSource라는 프로토콜에 의존하여 이루어진다.

    - 테이블 뷰 컨트롤러는 이 프로토콜을 참고하여 지정된 메소드를 호출함으로써 데이터 소스와 테이블 뷰를 연동한다.
    
    - 원래 대로라면 이 프로토콜을 상속받아야 하지만, 상속받고 있는 UITableViewController 클래스가 이미 해당 프로토콜을 상속받고 있으므로 다시금 상속받을 필요는 없다.
    
- 테이블 뷰에 데이터 소스를 연동할 때 필요한 내용은 다음 두 가지 이다.

    - 1) 테이블이 몇 개의 행으로 구성되는가?
    
    - 2) 각 행의 내용은 어떻게 구성되는가?
    
- 이들 두 가지 질문에 답하기 위한 메소드들이 UITableViewDataSource 프로토콜에 정의되어 있다.

    - 이들 메소드를 구현하여, 실제로 앱이 구동될 때 메소드가 호출되고 그 결과로 적절한 반환값을 받아갈 수 있도록 해 주어야 한다.
    
- - -

### 데이터 소스 연동을 위한 핵심 메소드

- 테이블 뷰와 데이터 소스를 연동하는 데 필요한 기본 메소드는 다음과 같다.

```swift
// 첫 번째 기본 필요 메소드
tableView(_:numberOfRowsInSection:)

// 두 번째 기본 필요 메소드
tableView(_:cellForRowAt:)
```

- 이 메소드들은 iOS 시스템이 필요에 의해 호출하는 메소드들이다. 

- 일종의 델리게이트 패턴을 따르고 있다.

- 동작이나 이벤트에 관한 메소드가 아니기 때문에 델리게이트라는 접미어를 붙이지는 않지만, 델리게이트 패턴과 동일한 방식으로 동작한다.

    - 시스템이 호출하는 함수인 콜백 함수(Callback Function)로 생각하면 된다.
    
    - 개발자가 알아서 적절한 시점에 호출하는 것이 아니라 작성해 두면 시스템이 알아서 호출하는 식이다.
    
- - -

### tableView(_:numberOfRowsInSection:)

- 이 메소드는 테이블 뷰가 생성해야 할 행(Row)의 개수를 반환한다.

- 이 메소드는 iOS 시스템이 테이블 뷰를 구성하기 위해 먼저 호출하는 메서드이다.

- 이 메소드는 개발자가 사용하기 위한 것이 아니라 시스템이 사용하기 위한 메소드이다.

    - 다시 말해, 현재 몇 개의 행이 구성되어 있는지를 개발자에게 알려주는 역활이 아니라 몇 개의 행을 생성해야 할지 개발자가 iOS 시스템에게 알려주기 위해 작성하는 메소드이다.
    
    - 더 정확히는 테이블 뷰를 구성하는 델리게이트에서 읽어 들이기 위한 용도인 것이다.
    
- 다시 한 번 강조하자면, 이 메소드는 이미 만들어진 테이블 뷰의 행 개수를 결과값으로 반환하는 용도가 아니다. 이 메소드에 의해 테이블 뷰의 행 수가 결정되는 것이다.

- 대다수의 GUI 개발에서 테이블 뷰의 행 수는 입력된 데이터 소스의 크기만큼 자동으로 만들어지지만, iOS에서 테이블 뷰를 구성할 때는 지정해 주는 개수만큼 행이 만들어진다.

- 이 메소드를 이용해서 테이블 뷰가 생성할 행의 개수를 작성해 놓으면 iOS 시스템은 메소드를 호출한 다음, 반환된 값만큼 목록을 생성한다.

    - 따라서 준비된 데이터 소스의 배열(Array) 길이가 백만 개쯤 된다 하더라도 이 메소드가 반환하는 값이 10이라면 화면에서는 열 개의 목록밖에 표시되지 않는다.
    
    - 반대로 데이터 소스에 저장된 아이템이 열 개밖에 되지 않는데 위 메소드에서 20을 반환해 버리면 iOS 시스템은 도합 스무 개의 행을 구성하기 위한 작업을 진행하게 된다.
    
        - 대개는 실행하는 시점에서 오류가 발생한다.
        
        - 그러니 생성해야 할 행 수는 개발자가 임의로 지정해주기보다는 데이터 소스의 크기를 동적으로 반환하는 방식으로 처리하는 것이 바람직하다.
        
```swift
// 이 메소드를 소스 코드에서 실제로 사용하는 형식.
// 인자의 종류와 타입이 함께 정의된 모습이다.

override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
    return 테이블 뷰의 목록 길이
}
```

- iOS가 이 메소드를 호출할 때는 두 개의 인자값을 함께 전달한다.

    - 1) 테이블 뷰 객체 정보
    
    - 2) 섹션 정보
    
- 첫 번째 인자값(_ tableView: UITablevView, 테이블 뷰 객체 정보)은 이 메소드를 호출한 테이블 뷰 객체에 대한 정보를 나타낸다.

- 하나의 뷰 컨트롤러 내에 두 개 이상의 테이블 뷰가 존재할 수 있지만, iOS 프로토콜 기반 설계 방식의 특성으로 인하여 개별 테이블 뷰 각각에 대한 메소드를 구분해서 작성하기란 어렵다.

    - 따라서 테이블 뷰가 여러 개일 때에도 모두 같은 메소드를 호출하게 된다.
    
        - 이때, 호출되는 메소드 입장에서는 어느 테이블 뷰에서 자신을 호출하는지를 알 필요가 있기 때문에, 이를 위해 첫 번째 인자값이 사용된다.
        
- 두 번째 인자값(numberOfRowsInSection section: Int, 섹션 정보)은 섹션에 대한 정보이다.

- 테이블 뷰는 일종의 행 그룹의 개념인 섹션으로 이루어질 수 있고, 그 하위에 개별 행이 추가된다.

- 섹션별로 행의 수를 다르게 구성할 수 있기 때문에 섹션에 따라 구분하여 행의 개수를 반환해야 할 때도 있다.

- 필요에 따라서는 테이블 뷰 정보와 섹션 정보를 바탕으로 반환값을 다르게 줄 수도 있다.

    - 예를 들어 이 테이블 뷰의 이 섹션은 3개의 행을 가져야 하고, 저 테이블 뷰의 저 섹션은 8개의 행을 가져야 한다라는 식.
    
- - -

### tableView(_:cellForRowAt:)

- 이 메소드는 각 행이 화면에 표현해야 할 내용을 구성하는 데에 사용된다.

- 하지만 이 메소드가 반환하는 값은 전체 테이블 뷰의 목록이 아니라 하나하나의 개별적인 테이블 셀 객체인데, 이는 화면에 표현해야 할 목록의 수 만큼 이 메소드가 반복적으로 호출된다는 것을 의미한다.

- 메소드 내에서 테이블 뷰 셀 객체를 구성한 다음 결과값으로 반환하면 시스템은 이 객체를 받아 테이블 뷰의 목록 각 행에 채워 넣는 방식이다.

- 개발자가 작성한 데이터 소스는 이 메소드 내부에서 활용되어 특정 행의 콘텐츠를 구성하는 데에 사용된다.

- iOS 시스템은 테이블 뷰를 구성하기 위해 먼저 'tableView(_:numberOfRowsInSection:)' 메소드를 호출하여 몇 개의 행을 생성해야 하는지를 반환받고, 그 수만큼 'tableView(_:cellForRowAt:)' 메소드를 호출한다.

- 매 호출 시마다 몇 번째 행에 대한 요청인지를 함께 전달하기 때문에 개발자는 이 값을 받아, 해당 행에 적절한 콘텐츠를 구성한 다음 이를 테이블 뷰 셀 객체 형태롤 리턴하면 된다.

- 이 메소드는 한 번 호출할 때마다 하나의 테이블 뷰 셀을 반환하므로 열 개의 행을 가진 목록을 구성하려면 모두 열 번의 호출이 필요하다(정확히는 아닐 수 있다).

```swift
// 인자값을 포함하여 소스 코드에서 사용되는 형식
override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
    return 테이블 뷰 셀 인스턴스
}
```

- iOS 시스템은 두 개의 인자값을 사용하여 이 메소드를 호출한다.

    - 1) 구성할 테이블 뷰 객체에 대한 참조
    
    - 2) 구성할 행에 대한 참조 정보
    
- 하나의 뷰 컨트롤러 안에 두 개 이상의 테이블 뷰가 사용될 경우, 첫 번째 인자값(_ tableView: UITableView, 구성할 테이블 뷰 객체에 대한 참조)으로 전달된 tableView 매개변수를 사용하면 어느 테이블 뷰에 대한 요청인지 쉽게 구분할 수 있다.

- 단순히 구분 용도만이 아니라 테이블 뷰 자체에 대한 참조가 필요할 때에도 사용할 수 있다.

- 첫 번째 매개변수를 통해 테이블 뷰가 특정되면, 이번에는 두 번째 매개변수인 'indexPath'를 통해 몇 번째 행을 구성하기 위한 호출인지 구분할 수 있다.

    - IndexPath 객체 타입으로 정의된 이 매개변수는 선택된 행에 대한 관련 속성들을 모두 제공한다.
    
    - 그중에서도 '.row'는 가장 많이 사용되는 속성으로, 행의 번호를 알려주는 역활을 한다.
    
    - 0부터 시작하는 이 행 번호는 배열(Array)로 이루어진 데이터 소스의 아이템 인덱스와 대부분의 경우 일치하므로 이 속성을 사용하면 데이터 소스의 필요한 부분을 편리하게 읽어 들일 수 있다.

- - -

### 사용자 액션 처리를 위한 핵심 메소드

- 일반적으로 테이블 뷰를 구성할 때 많이 사용되는 핵심 메소드, tableView(_:didSelectRowAt:)

- UITableViewDelegate 프로토콜에 정의된 이 메소드는 사용자가 목록 중에서 특정 행을 선택했을 때 호출된다.

- 보통 사용자가 선택한 내용에 맞는 액션을 처리하는 용도로 사용된다.

- 사용자가 행을 선택했을 때 딱히 처리해즐 액션 없이, 그저 화면에 목록을 표시하기만 하는 용도의 테이블 뷰라면 이 메소드를 구현할 필요는 없다.

- 반대로 사용자가 행을 선택했을 때 그에 맞게 화면을 이동하던가 혹은 상세 내용을 팝업으로 보여주는 등의 다양한 기능을 구현하고 싶다면 이 메소드를 구현해 주어야 한다.

    - 개발자는 이 메소드 내부에 원하는 로직을 작성하면 된다.
    
```swift
override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
}
```

- 이 메소드는 델리게이트 메소드이기 때문에 적절한 시점에 맞추어 자동으로 호출된다.

- 'tableView(_:numberOfRowsInSection:)'과 'tableView(_:cellForRowAt:)'는 테이블 뷰를 화면에 구현할 때 호출되는데 반해 'tableView(_:didSelectRowAt:)' 메소드는 사용자의 액션이 있을 때 호출된다는 차이점이 있다.

- iOS 시스템은 두 개의 인자값을 함께 전달한다.

    - 1) 사용자가 터치한 테이블 뷰에 대한 참조값
    
    - 2) 터치된 행에 대한 정보
    
- 이 두가지 인자값을 이용하여 개발자는 사용자가 어느 테이블 뷰의 몇 번째 행을 선택했는지를 확인 할 수 있으며, 새로운 화면으로 이동하는 코드를 작성하거나 알림창, 혹은 기타 기능을 작성하는 과정을 구현할 수 있다.

- - -

### 메소드 구현 실습

<img width="1058" alt="methodExampleImage-1" src="">

- 테이블 뷰 행의 개수를 반환하는 메소드를 작성한다.

- 이 메소드는 생성해야 할 행의 개수를 반환하는 메소드이다.

- iOS 시스템은 이 메소드가 반환하는 값만큼의 테이블 뷰 행을 생성한다.

- 메소드 호출 시 함께 전달되는 두 개의 매개변수 'tableView'와 'section'은 각각 어느 테이블 뷰인지, 그리고 테이블 뷰 내에서도 몇 번째 섹션에 대한 호출인지를 알려준다.

- 만약 여러 개의 테이블 뷰나 섹션이 존재한다면 두 개의 매개변수(tableView, section)를 통하여 어느 테이블 뷰의 어느 섹션인지를 구분하고, 이에 맞는 값을 반환하는 과정을 메소드 내에 추가해야 한다.

- 특별한 이유가 있지 않는 한, 테이블 뷰를 구성하는 행의 개수는 데이터 소스의 크기와 일치해야한다.

    - 따라서 이 메소드가 반환하는 값도 데이터 소스의 크기와 일치해야 한다. 고정값으로 반환값을 지정해 줄 수도 있지만(이를 '하드 코딩'이라고 부른다), 데이터 소스의 크기가 변경될 때마다 수정해 주어야 하므로 그보다는 데이터 소스의 크기가 바뀔 때마다 반환값도 함께 바뀌도록 처리해 주는 것이 좋다.
    
    - '.count' 속성은 배열(Array) 타입 객체의 길이를 가져오는 값으로, 데이터 소스 전체의 크기를 알기 위해 사용되었다.

<img width="1058" alt="methodExampleImage-2" src="">

- 테이블 뷰 행을 구성하는 메소드이다.

- 이 메소드는 개별 행을 만들어내는 역활을 한다.

- 'tableView(_:numberOfRowsInSection:)' 메소드가 반환하는 값만큼 이 메소드(tableView(_:cellForRowAt:))가 반복 호출된다.

- 이 메소드(tableView(_:cellForRowAt:))가 한 번 호출될 때마다 하나의 행이 만들어진다고 생각하면 된다.

- 몇 번째 행을 구성해야 하는지 알려주기 위해 'IndexPath' 타입의 객체가 인자값으로 전달된다.

- 행 번호를 알고자 할 때에는 'indexPath.row' 속성을 사용하면 된다.

    - 이 속성은 배열과 마찬가지로 0부터 시작한다.
    
    - 첫 번째 행이면 0을, 두 번째 행이면 1을 반환하는 식이다.
    
    - 이렇게 0부터 시작되는 행 번호는 배열의 인덱스와 일치하기 때문에 +1 또는 -1 할 필요 없이 배열 형식의 데이터 소스의 인덱스로 바로 사용할 수 있다.
    
    - 위 메소드에서 가장 먼저 처리하고 있는 것은 이 속성을 사용하여 'self.list' 배열로부터 데이터 소스를 읽어오는 것이다.
    
- - -

### Re