---
layout: post
title:  "Concurrency Programming Guide - 1"
date:   2019-08-31
categories: iOS, Swift, CS
---

# Introduction

---

- `동시성(Concurrency)는 동시에(same time) 발생하는 여러가지 것들의 개념`

- `멀티 코어 CPU의 확산`과 `각 프로세서의 코어 개수가 증가`할 것이라는 `인식` 때문에, `개발자`는 `코어를 활용 할 수 있는 새로운 방법`이 `필요`하다

- `OS X 및 iOS와 같은 운영체제`는 `여러 프로그램`을 `동시`에 `실행 할수 있지만`, `대부분의 프로그램`은 `백그라운드`에서 `실행`되며, `연속`으로 `프로세서 시간`이 `필요하지 않는 작업을 수행`한다.

- 컴퓨터를 계속 `사용`하고, `사용자의 주의`를 끄는 것은 현재 `forground 앱` 이다.

- `앱`이 `수행`해야 할 `작업`은 `많지만`, `사용 가능한 코어`의 `일부만 사용중인 경우`, `추가 처리 리소스`가 `낭비`된다.

- `과거`에는 `앱에 동시성`을 `도입`할 때, `하나 이상의 추가 쓰레드가 필요`했다 하지만 `쓰레드 코드`를 `작성`하는 것은 `어렵다`.

- `쓰레드`는 `수동`으로 `관리`해야하는 `하위 수준 도구`이다.

- `앱의 최적의 쓰레드 수`는 `현재 시스템 부하 및 기본 하드웨어를 기반`으로 `동적으로 변경될 수 있으므로`, `올바른 쓰레딩 솔루션 구현`은 불가능하지 않지만 `극도로 어려워진다`.

- 또한 `일반적`으로 `쓰레드와 함께 사용되는 동기화 메커니즘`은 `성능 향상`을 `보장하지 않으면서 소프트웨어 설계에 복잡성과 위험을 추가한다`.

- `OS X와 iOS`는 모두 `전통적`으로 `쓰레드 기반 시스템과 앱에 있는 것 보다`, `더 비동기적인 동시 태스크 실행 방식을 채택`하고 있다.

- `직접 쓰레드를 작성하는 대신`, `앱은 특정 태스크를 정의` 한 다음, `시스템이` 이를 `수행`하도록 해야한다.

- `시스템이 쓰레드를 관리`하게 함으로써 `원시 쓰레드(raw threads)`에서는 `불가능한 수준의 확장성`을 `얻을 수 있다.`

    - 앱 개밸자는 보다 간단하고 효율적인 프로그래밍 모델을 얻을 수 있다
    
---

# Concurrency and Application Design

비동기식 앱 설계의 기초와 사용자 정의 작업을 비동기적으로 수행하기 위한 기술

---

**용어에 대한 참고사항**

- 이 포스트에서는 task, process, thread 라는 용어가 약간 다르게 사용된다

    - `task(작업)` -> 수행해야 할 추상적인 작업 개념을 나타내기 위해 사용
    
    - `process(프로세스)` -> 실행 중인 실행파일(running executable)을 지칭, 여러 쓰레드를 포함 할 수 있다.
    
    - `thread(쓰레드)` -> 코드 실행을 위한 별도로 실행 경로(path)를 지칭하기 위해 사용
    
---

- 컴퓨팅 초기에는 컴퓨터가 `수행할 수 있는 단위`, `시간 당 최대 작업량`이 `CPU의 클럭 속도`에 의해 `결정`

    - 용어 : 클럭 속도 또는 클록 주파수는 컴퓨터 프로세서의 동작 속도이다. "초당 사이클"로 측정하며 헤르츠 단위를 사용한다
    
- 첨단 기술과 프로세서 설계가 더욱 `소형화`됨에 따라, `열(heat) 및 기타 물리적 제약`이 `프로세서의 최대 클럭 속도를 제한하기 시작`

- 그래서 칩 제조업체는 `칩의 총 성능을 향상`시키는 `다른 방법`을 `모색`했다. 

    - 칩 제조업체의 `해결책`은 `각 칩`의 `프로세서 코어 수를 늘리는 것`이었다.

- `코어 수`를 늘리면, `CPU의 속도를 높이거나` `칩 크기` 또는 `열(heat) 특성`을 `변경하지 않고도 단일 칩에서 초당 더 많은 명령을 실행 할 수 있다.`

    - 유일한 문제는 `여분의 코어를 이용하는 방법`이었다.
    
- `여러개의 코어`를 `활용`하려면, `여러가지 작업`을 `동시`에 `수행 할수 있는 소프트웨어가 필요`하다.

- `OS X 또는 iOS`와 같은 `최신 멀티 태스킹 운영체제`의 경우, `주어진 시간`에 `100개 이상`의 `다른 코어에 프로그램이 실행`될 수 있으므로, `각 프로그램을 다른 코어에 스케쥴링 할수 있어야 한다.`

- 이러한 `프로그램(여러가지 작업을 동시에 수행 할 수 있는 소프트웨어)`의 `대부분은 시스템 데몬`이거나, `실제 처리 시간을 거의 소비하지 않는 백그라운드 앱`이다, `실제로 필요한 것`은 `개별 앱`이 `여분의 코어`를 보다 `효과적으로 사용하는 방법`이다.

    - 용어 : 멀티태스킹 운영 체제에서 데몬(daemon, 발음: 데이먼/'deɪmən/ 또는 디먼 /'dimən)은 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다. 

- `앱이 여러 코어를 사용`하는 `전통적인 방법`은 `여러 쓰레드를 만드는 것`이다

    - 그러나 `코어 수`가 `늘어나면`, `쓰레드 솔루션`에 `문제`가 생긴다

    - `가장 큰 문제`는 `쓰레드 된 코드`가 `임의의 수의 코어`에 `맞게 확장되지 않았다`는 것
    
- `코어와 프로그램이 잘 돌아갈 것`으로 `기대하는 것 만큼 많은 쓰레드를 생성 할 수 없다.`
    
- 알아야 할 것은, `효과적`으로` 사용 할 수 있는 코어의 수`는 `앱 자체에서 계산하기 어려운 수준`이다

    - 비록 숫자를 `정확하게 맞춘다고 할지라도`, 여전히 `너무나 많은 쓰레드를 프로그래밍`하고, `그것들을 효과적으로 운영`하고, `그것들이 서로 간섭하지 못하게` 해야한다.
    
- 문제를 요약하지먼, `앱이 다양한 컴퓨터 코어들의 수를 이용 할수 있는 방법이 필요`하다

- `단일 앱`이 `수행하는 작업량` 또는 `변화하는 시스템 조건`을 `수용` 할수 있도록 `동적으로 확장` 할수 있어야 한다

- `솔루션`은 이러한 `코어`를 `활용`하는데 `필요한 작업량을 늘리지 않도록 충분히 감당해야 한다`

---

## The Move Away from Threads

---

- `쓰레드`는 `수년간 사용`되어왔으며, `계속 사용`되고는 있지만 `확장 가능한 방식`으로 `여러 작업을 실행`하는 `일반적인 문제를 해결하지는 못한다`

- `쓰레드를 활용할 경우`, `확장 가능한 솔루션`을 `구축`해야하는 `부담`이 `전적으로 개발자`에게 있다

- `시스템 조건`이 `변경됨`에 따라, `동적`으로 `해당 수를 생성`하고 `조정할 쓰레드 수를 결정`해야 한다

- 앱이 해당 쓰레드를 생성하고 `유지보수하는데 드는 비용의 대부분`을 떠맡는다.

- `동시성(Concurrency)문제`를 `해결`하기 위해, OS X와 iOS는 `쓰레드에 의존하는 대신`, `비동기 설계 접근 방식`을 사용

- `비동기 기능`은 운영체제에 여러해 동안 존재해왔으며, 디스크에서 데이터를 읽는 것과 같이 `오랜시간이 걸릴 수 있는 작업`을 `시작`하는데 종종 사용된다.

- `비동기 함수`는 `호출 될 때 백그라운드에서 일부 작업을 수행`하여 `실행중인 task를 시작`하지만, `해당 작업이 실제로 완료되기 전에 반환`한다.

- `일반적으로 이 작업`에는 `백그라운드 쓰레드를 가져오고`, `해당 쓰레드`에서 `원하는 task를 시작한 다음`, `task가 완료`될 때, `호출자에게 알림`을 보내는 `작업이 포함`된다.

- `과거`에는 원하는 작업에 대해 `비동기 함수가 존재하지 않는 경우`, `자체적으로 비동기 함수를 작성`하여 `고유의 쓰레드를 생성`해야 했다.

- 하지만 이제 OS X와 iOS는 `직접 쓰레드를 관리하지 않고`도 `비동기식`으로 `모든 작업을 수행`할 수 있도록 해주는 `기술을 제공`한다

---

## GCD (Grand Central Dispatch)

**비동기식으로 task를 시작하는 기술 중 하나**

- `GCD`는 일반적으로 `자신의 앱에서 쓰는 쓰레드 관리 코드`를 `사용`하여 `해당 코드를 시스템 수준`으로 `이동`시킨다.

- `실행할 작업을 정의`하고, `이를 적절한 dispatch queue에 추가`하기만 하면 된다

- `GCD`는 `필요한 쓰레드를 생성`하고 `해당 쓰레드에서 실행되도록 작업`을 `스케쥴링`한다

- `쓰레드 관리`가 이제 `시스템의 일부`이므로 `GCD`는 `작업 관리` 및 `실행`에 대한 `전체적인 접근 방식`을 `제공`하여, 전통적인 쓰레드보다 `더 나은 효율성`을 제공한다.

- `Operation queues` 는 `dispatch queues`와 매우 `유사`한 `Objective-C 객체`이다.

    - `실행 할 작업`을 `정의한 다음`, `operation queue애 추가`하여 `해당 작업의 스케줄링 및 실행`을 `처리`한다
    
    - `GCD`와 마찬가지로 `operation queue`는 모든 `쓰레드 관리를 처리`하여 `시스템`에서 `가능한 한 신속하고 효율적`으로 `작업`을 `실행`하도록 한다.

---

## Dispatch Queues

- `dispatch queues`는 `사용자 지정 작업`을 `실행`하기 위한 `C기반 매커니즘`이다.

- `dispatch queues`는 `작업을 순차적으로 또는 동시에 수행`하지만, `항상 FIFO(first-in, first-out)로 수행`한다.

- `dispatch queues`는 항상 `큐에 추가된 것과 동일한 순서로 작업을 큐에서 제외하고 시작`한다.

- `Serial dispatch queues`는 `한번에 하나의 작업만 실행`하며 `해당 task가 완료될 때 까지 기다린 후, 새 task를 시작`한다

- `반대로 concurrent dispatch queues`는 `이미 시작된 작업이 완료될 때 까지 기다리지 않고`, `가능한 많은 작업을 시작`한다.

---

### Dispatch queues의 이점(benefits)

- Dispatch queues는 `이해하기 쉽고 간단한 인터페이스를 제공`

- Dispatch queues는 `자동 및 전체적인 thread pool 관리 기능을 제공`

- Dispatch queues는 `튜닝된 어셈블리의 속도를 제공`

- Dispatch queues는 `쓰레드 스택이 앱 메모리에 남아있지 않기 때문에 훨씬 효율적`이다

- Dispatch queues는 `로드중인 커널에 걸리지 않는다`

- Dispatch queues에 `task(작업)을 비동기적`으로 `전달`하면 `대기열이 교착상태(Dead Lock)로 만들어 지지 않는다`

- Dispatch queues는 `자원경쟁 하에 우아하게 확장`된다.

- Serial dispatch queues는 `lock 및 기타 동기화 기본 요소에 대한보다 효율적인 대안을 제공`.

---

- `dispatch queue에 보내는 작업`은 `함수 또는 블록` 객체 내에 `캡슐화`되어야 한다.

- `블록객체`는 OS X v10.6 및 iOS 4.0에 도입된 `C언어 기능`으로, `개념적으로 포인터와 유사`하지만 `몇가지 추가적인 이점`이 있다.

    - `블록`을 `자신만의 어휘 범위에서(own lexical scope)정의`하는 `대신에 일반적으로 다른 함수나 메소드의 다른 변수에 엑세스(접근) 할 수 있도록 다른 기능이나 메소드 내부에 블록을 정의`한다
    
    - `블록을 원래 범위 밖으로 이동`하여 `heap`으로 `복사`할 수도 있다
    
- `dispatch queue`에 `블록을 보내면`, `블록이 복사`된다.

- `이러한 모든 의미`는 `상대적으로 적은 코드`로 `매우 동적인 작업`을 `구현`할 수 있게 한다

- `dispatch queue`는 `GCD기술의 일부`이며 `C런타임의 일부`이다

---

## 모르는 용어나 개념에 대한 부가적인 정리

#### thread pool

![threadPool](https://user-images.githubusercontent.com/42841888/64060534-0a3c3280-cc09-11e9-992b-c1e692a0fc76.png)

- 병렬 작업 처리가 많아지면 쓰레드 개수가 증가되고 그에 따른 쓰레드 생성과 스케줄링으로 인해 CPU가 바빠져 메모리 사용량이 늘어난다, 따라서 어플리케이션의 성능이 저하된다. 

- 갑작스런 병렬작업의 극대화로 인한 쓰레드 증폭을 막으려면 thread pool을 사용해야 한다. 

- thread pool은 작업 처리에 사용되는 쓰레드를 제한된 개수만큰 정해 놓고 작업 Queue에 들어오는 작업들을 하나씩 쓰레드가 맡아 처리한다.

#### kernel

- 컴퓨터의 커널은 운영체제의 핵심입니다. 

- 운영체제의 다른 모든 부분에 여러 기본적인 서비스를 제공합니다. 

- 시스템 자원은 제한되어있지만 프로그램은 많기 때문에 커널은 프로그램의 수행상태인 프로세스 간의 보안 접근을 책임지는 소프트웨어입니다. 

- 커널이 이러한 프로세스마다 얼마만큼의 자원을 사용해야 하는지 결정해야하는데 이것을 스케줄링이라고 합니다

#### heap

![img_c_memory_structure](https://user-images.githubusercontent.com/42841888/64061040-c39e0680-cc0f-11e9-92f5-35790101b460.png)

- 필요에 의해 동적으로 메모리를 할당 할 때 사용

- 할당해야 할 메모리의 크기를 프로그램이 실행되는 동안 결정해야 하는 경우 (Run time 때) 유용하게 사용되는 공간 = 힙 영역

- 사용자의 요구에 맞게 메모리를 할당해 주기 위해서 (런타임에 메모리 크기를 결정하고 싶을 때) `메모리 동적 할당` 을 통해 힙 영역에 메모리를 할당해야 한다.


---

출처: https://zeddios.tistory.com/509 [ZeddiOS]
출처: https://12bme.tistory.com/288 [길은 가면, 뒤에 있다.]
출처: https://dsnight.tistory.com/50[Development Assemble]